/* Chart.js - Local Minimal Version for Cyberpunk Dashboard */

// Simple Chart.js replacement for basic functionality
window.Chart = {
  // Chart types
  Line: function(ctx, config) {
    return new CyberpunkChart(ctx, 'line', config);
  },
  Bar: function(ctx, config) {
    return new CyberpunkChart(ctx, 'bar', config);
  },
  Doughnut: function(ctx, config) {
    return new CyberpunkChart(ctx, 'doughnut', config);
  },
  Pie: function(ctx, config) {
    return new CyberpunkChart(ctx, 'pie', config);
  },
  
  // Default configuration
  defaults: {
    global: {
      defaultColor: '#4cc9f0',
      defaultFontColor: '#e0e0e0',
      defaultFontFamily: 'Inter, sans-serif'
    }
  }
};

// Cyberpunk Chart Implementation
class CyberpunkChart {
  constructor(ctx, type, config) {
    this.ctx = ctx;
    this.canvas = ctx.canvas;
    this.type = type;
    this.config = config || {};
    this.data = config.data || {};
    this.options = config.options || {};
    
    this.init();
  }
  
  init() {
    this.setupCanvas();
    this.render();
  }
  
  setupCanvas() {
    const canvas = this.canvas;
    const rect = canvas.getBoundingClientRect();
    
    // Set canvas size
    canvas.width = rect.width * 2; // High DPI
    canvas.height = rect.height * 2;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    
    // Scale context for high DPI
    this.ctx.scale(2, 2);
    
    // Set cyberpunk styling
    this.ctx.fillStyle = '#0a0e17';
    this.ctx.fillRect(0, 0, rect.width, rect.height);
  }
  
  render() {
    const rect = this.canvas.getBoundingClientRect();
    const width = rect.width;
    const height = rect.height;
    
    // Clear canvas
    this.ctx.clearRect(0, 0, width, height);
    
    // Draw background
    this.ctx.fillStyle = 'rgba(10, 14, 23, 0.9)';
    this.ctx.fillRect(0, 0, width, height);
    
    // Draw border
    this.ctx.strokeStyle = '#4cc9f0';
    this.ctx.lineWidth = 2;
    this.ctx.strokeRect(1, 1, width - 2, height - 2);
    
    switch(this.type) {
      case 'line':
        this.renderLineChart(width, height);
        break;
      case 'bar':
        this.renderBarChart(width, height);
        break;
      case 'doughnut':
      case 'pie':
        this.renderDoughnutChart(width, height);
        break;
      default:
        this.renderPlaceholder(width, height);
    }
  }
  
  renderLineChart(width, height) {
    const datasets = this.data.datasets || [];
    const labels = this.data.labels || [];
    
    if (datasets.length === 0 || labels.length === 0) {
      this.renderPlaceholder(width, height);
      return;
    }
    
    const padding = 40;
    const chartWidth = width - (padding * 2);
    const chartHeight = height - (padding * 2);
    
    // Draw grid
    this.ctx.strokeStyle = 'rgba(76, 201, 240, 0.2)';
    this.ctx.lineWidth = 1;
    
    // Vertical grid lines
    for (let i = 0; i <= 5; i++) {
      const x = padding + (chartWidth / 5) * i;
      this.ctx.beginPath();
      this.ctx.moveTo(x, padding);
      this.ctx.lineTo(x, height - padding);
      this.ctx.stroke();
    }
    
    // Horizontal grid lines
    for (let i = 0; i <= 4; i++) {
      const y = padding + (chartHeight / 4) * i;
      this.ctx.beginPath();
      this.ctx.moveTo(padding, y);
      this.ctx.lineTo(width - padding, y);
      this.ctx.stroke();
    }
    
    // Draw data lines
    datasets.forEach((dataset, index) => {
      const data = dataset.data || [];
      const color = dataset.borderColor || '#4cc9f0';
      
      this.ctx.strokeStyle = color;
      this.ctx.lineWidth = 3;
      this.ctx.beginPath();
      
      data.forEach((value, i) => {
        const x = padding + (chartWidth / (data.length - 1)) * i;
        const y = height - padding - (value / 100) * chartHeight;
        
        if (i === 0) {
          this.ctx.moveTo(x, y);
        } else {
          this.ctx.lineTo(x, y);
        }
      });
      
      this.ctx.stroke();
      
      // Draw points
      this.ctx.fillStyle = color;
      data.forEach((value, i) => {
        const x = padding + (chartWidth / (data.length - 1)) * i;
        const y = height - padding - (value / 100) * chartHeight;
        
        this.ctx.beginPath();
        this.ctx.arc(x, y, 4, 0, Math.PI * 2);
        this.ctx.fill();
      });
    });
  }
  
  renderBarChart(width, height) {
    const datasets = this.data.datasets || [];
    const labels = this.data.labels || [];
    
    if (datasets.length === 0 || labels.length === 0) {
      this.renderPlaceholder(width, height);
      return;
    }
    
    const padding = 40;
    const chartWidth = width - (padding * 2);
    const chartHeight = height - (padding * 2);
    
    const dataset = datasets[0];
    const data = dataset.data || [];
    const barWidth = chartWidth / data.length * 0.8;
    const barSpacing = chartWidth / data.length * 0.2;
    
    data.forEach((value, i) => {
      const x = padding + (chartWidth / data.length) * i + barSpacing / 2;
      const barHeight = (value / 100) * chartHeight;
      const y = height - padding - barHeight;
      
      // Draw bar
      const gradient = this.ctx.createLinearGradient(0, y, 0, y + barHeight);
      gradient.addColorStop(0, '#4cc9f0');
      gradient.addColorStop(1, 'rgba(76, 201, 240, 0.3)');
      
      this.ctx.fillStyle = gradient;
      this.ctx.fillRect(x, y, barWidth, barHeight);
      
      // Draw bar border
      this.ctx.strokeStyle = '#4cc9f0';
      this.ctx.lineWidth = 2;
      this.ctx.strokeRect(x, y, barWidth, barHeight);
    });
  }
  
  renderDoughnutChart(width, height) {
    const datasets = this.data.datasets || [];
    
    if (datasets.length === 0) {
      this.renderPlaceholder(width, height);
      return;
    }
    
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 3;
    const innerRadius = radius * 0.6;
    
    const dataset = datasets[0];
    const data = dataset.data || [];
    const colors = ['#4cc9f0', '#8A2BE2', '#39FF14', '#FF6B35', '#ff6b6b'];
    
    const total = data.reduce((sum, value) => sum + value, 0);
    let currentAngle = -Math.PI / 2;
    
    data.forEach((value, i) => {
      const sliceAngle = (value / total) * Math.PI * 2;
      const color = colors[i % colors.length];
      
      // Draw slice
      this.ctx.beginPath();
      this.ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
      this.ctx.arc(centerX, centerY, innerRadius, currentAngle + sliceAngle, currentAngle, true);
      this.ctx.closePath();
      
      this.ctx.fillStyle = color;
      this.ctx.fill();
      
      this.ctx.strokeStyle = '#0a0e17';
      this.ctx.lineWidth = 2;
      this.ctx.stroke();
      
      currentAngle += sliceAngle;
    });
  }
  
  renderPlaceholder(width, height) {
    // Draw placeholder text
    this.ctx.fillStyle = '#4cc9f0';
    this.ctx.font = '16px Inter, sans-serif';
    this.ctx.textAlign = 'center';
    this.ctx.textBaseline = 'middle';
    
    this.ctx.fillText('Chart Data Loading...', width / 2, height / 2 - 10);
    this.ctx.fillText('Cyberpunk Analytics', width / 2, height / 2 + 10);
    
    // Draw loading animation
    const time = Date.now() / 1000;
    const angle = time * 2;
    
    this.ctx.strokeStyle = '#4cc9f0';
    this.ctx.lineWidth = 3;
    this.ctx.beginPath();
    this.ctx.arc(width / 2, height / 2 + 40, 15, angle, angle + Math.PI);
    this.ctx.stroke();
  }
  
  update() {
    this.render();
  }
  
  destroy() {
    // Cleanup
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
}

// Export for global use
if (typeof module !== 'undefined' && module.exports) {
  module.exports = Chart;
}

// Initialize charts when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  console.log('ðŸ”® Cyberpunk Chart.js Loaded');
});

// Auto-refresh charts every 5 seconds
setInterval(() => {
  const charts = document.querySelectorAll('canvas[data-chart]');
  charts.forEach(canvas => {
    if (canvas.chart && typeof canvas.chart.update === 'function') {
      canvas.chart.update();
    }
  });
}, 5000);